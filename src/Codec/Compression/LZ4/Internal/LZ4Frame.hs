-- GENERATED by C->Haskell Compiler, version 0.26.1 Budburst, 4 April 2015 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}
{-# LANGUAGE CPP, ForeignFunctionInterface #-}
module Codec.Compression.LZ4.Internal.LZ4Frame where
import qualified Foreign.C.Types as C2HSImp
import qualified Foreign.Ptr as C2HSImp
import qualified System.IO.Unsafe as C2HSImp





import Data.String
import Data.Word
import Foreign.C.Types


{-# LINE 10 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}


version :: Int
version = 100
{-# LINE 13 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

data BlockSizeID = Default
                 | Max64KB
                 | Max256KB
                 | Max1MB
                 | Max4MB
  deriving (Show)
instance Enum BlockSizeID where
  succ Default = Max64KB
  succ Max64KB = Max256KB
  succ Max256KB = Max1MB
  succ Max1MB = Max4MB
  succ Max4MB = error "BlockSizeID.succ: Max4MB has no successor"

  pred Max64KB = Default
  pred Max256KB = Max64KB
  pred Max1MB = Max256KB
  pred Max4MB = Max1MB
  pred Default = error "BlockSizeID.pred: Default has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from Max4MB

  fromEnum Default = 0
  fromEnum Max64KB = 4
  fromEnum Max256KB = 5
  fromEnum Max1MB = 6
  fromEnum Max4MB = 7

  toEnum 0 = Default
  toEnum 4 = Max64KB
  toEnum 5 = Max256KB
  toEnum 6 = Max1MB
  toEnum 7 = Max4MB
  toEnum unmatched = error ("BlockSizeID.toEnum: Cannot match " ++ show unmatched)

{-# LINE 16 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

data BlockMode = BlockLinked
               | BlockIndependent
  deriving (Show)
instance Enum BlockMode where
  succ BlockLinked = BlockIndependent
  succ BlockIndependent = error "BlockMode.succ: BlockIndependent has no successor"

  pred BlockIndependent = BlockLinked
  pred BlockLinked = error "BlockMode.pred: BlockLinked has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from BlockIndependent

  fromEnum BlockLinked = 0
  fromEnum BlockIndependent = 1

  toEnum 0 = BlockLinked
  toEnum 1 = BlockIndependent
  toEnum unmatched = error ("BlockMode.toEnum: Cannot match " ++ show unmatched)

{-# LINE 19 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

data ContentChecksum = NoContentChecksum
                     | ContentChecksumEnabled
  deriving (Show)
instance Enum ContentChecksum where
  succ NoContentChecksum = ContentChecksumEnabled
  succ ContentChecksumEnabled = error "ContentChecksum.succ: ContentChecksumEnabled has no successor"

  pred ContentChecksumEnabled = NoContentChecksum
  pred NoContentChecksum = error "ContentChecksum.pred: NoContentChecksum has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from ContentChecksumEnabled

  fromEnum NoContentChecksum = 0
  fromEnum ContentChecksumEnabled = 1

  toEnum 0 = NoContentChecksum
  toEnum 1 = ContentChecksumEnabled
  toEnum unmatched = error ("ContentChecksum.toEnum: Cannot match " ++ show unmatched)

{-# LINE 22 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

data FrameType = Frame
               | SkippableFrame
  deriving (Show)
instance Enum FrameType where
  succ Frame = SkippableFrame
  succ SkippableFrame = error "FrameType.succ: SkippableFrame has no successor"

  pred SkippableFrame = Frame
  pred Frame = error "FrameType.pred: Frame has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from SkippableFrame

  fromEnum Frame = 0
  fromEnum SkippableFrame = 1

  toEnum 0 = Frame
  toEnum 1 = SkippableFrame
  toEnum unmatched = error ("FrameType.toEnum: Cannot match " ++ show unmatched)

{-# LINE 25 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}


type SizeTPtr = Ptr CSize
newtype VoidPtr = VoidPtr (Ptr VoidPtr)
type ErrorCode = CSize

-- Write storable instance. do not forget to end-pad with reserved: unsigned[2]
data FrameInfo = FrameInfo
 { blockSizeId  :: BlockSizeID
 , blockMode    :: BlockMode
 , checksumFlag :: ContentChecksum
 , frameType    :: FrameType
 , contentSize  :: Word64}

-- Write storable instance. do not forget to end-pad with reserved: unsigned[4]
data Prefs = Prefs
  { frameInfo        :: FrameInfo
  , compressionLevel :: Int
  , autoFlush        :: Bool }

-- Write storable instance. do not forget to end-pad with resperved: unsigned[3]
data CompressOpts = CompressOpts
    { stableSrc :: Word }

-- Write storable instance. do not forget to end-pad with reserved: unsigned[3]
data DecompressOpts = DecompressOpts
    { stableDst :: Word}

newtype PrefsPtr = PrefsPtr (C2HSImp.Ptr (PrefsPtr))
{-# LINE 53 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

newtype CompressOptsPtr = CompressOptsPtr (C2HSImp.Ptr (CompressOptsPtr))
{-# LINE 54 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

-- Opaque pointer type. Must be 8-byte aligned, but this is opaque to us.
newtype CompressionCxt = CompressionCxt (C2HSImp.Ptr (CompressionCxt))
{-# LINE 56 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

newtype CompressionCxtPtr = CompressionCxtPtr (C2HSImp.Ptr (CompressionCxtPtr))
{-# LINE 57 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

newtype DecompressionCxt = DecompressionCxt (C2HSImp.Ptr (DecompressionCxt))
{-# LINE 58 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

type DecompressionCxtPtr = C2HSImp.Ptr ((C2HSImp.Ptr ()))
{-# LINE 59 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}


isError :: (ErrorCode) -> ((Word), (ErrorCode))
isError a1 =
  C2HSImp.unsafePerformIO $
  let {a1' = fromIntegral a1} in 
  isError'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = fromIntegral  a1'} in 
  return (res', a1'')

{-# LINE 62 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

getErrorName :: (ErrorCode) -> ((CString), (ErrorCode))
getErrorName a1 =
  C2HSImp.unsafePerformIO $
  let {a1' = fromIntegral a1} in 
  getErrorName'_ a1' >>= \res ->
  let {res' = fromString res} in
  let {a1'' = fromIntegral  a1'} in 
  return (res', a1'')

{-# LINE 64 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressFrameBound :: (CSize) -> (PrefsPtr) -> IO ((CSize), (CSize), (PrefsPtr))
compressFrameBound a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = id a2} in 
  compressFrameBound'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = fromIntegral  a1'} in 
  let {a2'' = id  a2'} in 
  return (res', a1'', a2'')

{-# LINE 67 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressFrame :: (VoidPtr) -> (CSize) -> (VoidPtr) -> (PrefsPtr) -> IO ((CSize), (VoidPtr), (CSize), (VoidPtr), (PrefsPtr))
compressFrame a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = id a3} in 
  let {a4' = id a4} in 
  compressFrame'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = id  a1'} in 
  let {a2'' = fromIntegral  a2'} in 
  let {a3'' = id  a3'} in 
  let {a4'' = id  a4'} in 
  return (res', a1'', a2'', a3'', a4'')

{-# LINE 72 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

createCompressionContext :: (CompressionCxtPtr) -> (Word) -> IO ((ErrorCode), (CompressionCxtPtr), (Word))
createCompressionContext a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  createCompressionContext'_ a1' a2' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = fromIntegral  a2'} in 
  return (res', a1'', a2'')

{-# LINE 75 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

freeCompressionContext :: (CompressionCxt) -> IO ((ErrorCode), (CompressionCxt))
freeCompressionContext a1 =
  let {a1' = id a1} in 
  freeCompressionContext'_ a1' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  return (res', a1'')

{-# LINE 77 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressBegin :: (CompressionCxt) -> (VoidPtr) -> (CSize) -> (PrefsPtr) -> IO ((ErrorCode), (CompressionCxt), (VoidPtr), (CSize), (PrefsPtr))
compressBegin a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  compressBegin'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = fromIntegral  a3'} in 
  let {a4'' = id  a4'} in 
  return (res', a1'', a2'', a3'', a4'')

{-# LINE 82 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressBound :: (CSize) -> (PrefsPtr) -> IO ((CSize), (CSize), (PrefsPtr))
compressBound a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = id a2} in 
  compressBound'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = fromIntegral  a1'} in 
  let {a2'' = id  a2'} in 
  return (res', a1'', a2'')

{-# LINE 85 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressUpdate :: (CompressionCxt) -> (VoidPtr) -> (VoidPtr) -> (CSize) -> (CompressOptsPtr) -> IO ((ErrorCode), (CompressionCxt), (VoidPtr), (VoidPtr), (CSize), (CompressOptsPtr))
compressUpdate a1 a2 a3 a4 a5 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  let {a4' = fromIntegral a4} in 
  let {a5' = id a5} in 
  compressUpdate'_ a1' a2' a3' a4' a5' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = id  a3'} in 
  let {a4'' = fromIntegral  a4'} in 
  let {a5'' = id  a5'} in 
  return (res', a1'', a2'', a3'', a4'', a5'')

{-# LINE 91 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

flush :: (CompressionCxt) -> (VoidPtr) -> (CSize) -> (CompressOptsPtr) -> IO ((ErrorCode), (CompressionCxt), (VoidPtr), (CSize), (CompressOptsPtr))
flush a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  flush'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = fromIntegral  a3'} in 
  let {a4'' = id  a4'} in 
  return (res', a1'', a2'', a3'', a4'')

{-# LINE 96 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

compressEnd :: (CompressionCxt) -> (VoidPtr) -> (CSize) -> (CompressOptsPtr) -> IO ((ErrorCode), (CompressionCxt), (VoidPtr), (CSize), (CompressOptsPtr))
compressEnd a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = id a4} in 
  compressEnd'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = fromIntegral  a3'} in 
  let {a4'' = id  a4'} in 
  return (res', a1'', a2'', a3'', a4'')

{-# LINE 101 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

createDecompressionContext :: (DecompressionCxtPtr) -> (Word) -> IO ((ErrorCode), (DecompressionCxtPtr), (Word))
createDecompressionContext a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  createDecompressionContext'_ a1' a2' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  let {a2'' = fromIntegral  a2'} in 
  return (res', a1'', a2'')

{-# LINE 104 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

freeDecompressionContext :: (DecompressionCxt) -> IO ((ErrorCode), (DecompressionCxt))
freeDecompressionContext a1 =
  let {a1' = id a1} in 
  freeDecompressionContext'_ a1' >>= \res ->
  let {res' = id res} in
  let {a1'' = id  a1'} in 
  return (res', a1'')

{-# LINE 106 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

getFrameInfo :: (DecompressionCxt) -> (FrameInfoPtr) -> (VoidPtr) -> (SizeTPtr) -> IO ((CSize), (DecompressionCxt), (FrameInfoPtr), (VoidPtr), (SizeTPtr))
getFrameInfo a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  let {a4' = id a4} in 
  getFrameInfo'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = id  a3'} in 
  let {a4'' = id  a4'} in 
  return (res', a1'', a2'', a3'', a4'')

{-# LINE 111 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}

decompress :: (DecompressionCxt) -> (VoidPtr) -> (SizeTPtr) -> (VoidPtr) -> (SizeTPtr) -> (DecompressOptsPtr) -> IO ((CSize), (DecompressionCxt), (VoidPtr), (SizeTPtr), (VoidPtr), (SizeTPtr), (DecompressOptsPtr))
decompress a1 a2 a3 a4 a5 a6 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  let {a4' = id a4} in 
  let {a5' = id a5} in 
  let {a6' = id a6} in 
  decompress'_ a1' a2' a3' a4' a5' a6' >>= \res ->
  let {res' = fromIntegral res} in
  let {a1'' = id  a1'} in 
  let {a2'' = id  a2'} in 
  let {a3'' = id  a3'} in 
  let {a4'' = id  a4'} in 
  let {a5'' = id  a5'} in 
  let {a6'' = id  a6'} in 
  return (res', a1'', a2'', a3'', a4'', a5'', a6'')

{-# LINE 118 "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs" #-}


foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_isError"
  isError'_ :: (C2HSImp.CULong -> (IO C2HSImp.CUInt))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_getErrorName"
  getErrorName'_ :: (C2HSImp.CULong -> (IO (C2HSImp.Ptr C2HSImp.CChar)))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressFrameBound"
  compressFrameBound'_ :: (C2HSImp.CULong -> ((PrefsPtr) -> (IO C2HSImp.CULong)))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressFrame"
  compressFrame'_ :: ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> (IO C2HSImp.CULong)))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_createCompressionContext"
  createCompressionContext'_ :: ((CompressionCxtPtr) -> (C2HSImp.CUInt -> (IO C2HSImp.CULong)))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_freeCompressionContext"
  freeCompressionContext'_ :: ((CompressionCxt) -> (IO C2HSImp.CULong))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressBegin"
  compressBegin'_ :: ((CompressionCxt) -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> ((PrefsPtr) -> (IO C2HSImp.CULong)))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressBound"
  compressBound'_ :: (C2HSImp.CULong -> ((PrefsPtr) -> (IO C2HSImp.CULong)))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressUpdate"
  compressUpdate'_ :: ((CompressionCxt) -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> (IO C2HSImp.CULong))))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_flush"
  flush'_ :: ((CompressionCxt) -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> ((CompressOptsPtr) -> (IO C2HSImp.CULong)))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_compressEnd"
  compressEnd'_ :: ((CompressionCxt) -> ((C2HSImp.Ptr ()) -> (C2HSImp.CULong -> ((CompressOptsPtr) -> (IO C2HSImp.CULong)))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_createDecompressionContext"
  createDecompressionContext'_ :: ((DecompressionCxtPtr) -> (C2HSImp.CUInt -> (IO C2HSImp.CULong)))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_freeDecompressionContext"
  freeDecompressionContext'_ :: ((DecompressionCxt) -> (IO C2HSImp.CULong))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_getFrameInfo"
  getFrameInfo'_ :: ((DecompressionCxt) -> ((C2HSImp.Ptr ()) -> ((C2HSImp.Ptr ()) -> ((C2HSImp.Ptr C2HSImp.CULong) -> (IO C2HSImp.CULong)))))

foreign import ccall unsafe "src/Codec/Compression/LZ4/Internal/LZ4Frame.chs.h LZ4F_decompress"
  decompress'_ :: ((DecompressionCxt) -> ((C2HSImp.Ptr ()) -> ((C2HSImp.Ptr C2HSImp.CULong) -> ((C2HSImp.Ptr ()) -> ((C2HSImp.Ptr C2HSImp.CULong) -> ((C2HSImp.Ptr ()) -> (IO C2HSImp.CULong)))))))
